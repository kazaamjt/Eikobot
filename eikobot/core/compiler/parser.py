"""
The parser is the single most important part of the Eikobot Compiler.
It takes tokens generated by the lexer and tries to make sense of them,
Returning them as ASTs.
These ASTs in turn can be compiled to Eikobot data.
"""
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterator, List, Optional, Union

from .definitions.base_types import (
    EikoBaseType,
    EikoBool,
    EikoFloat,
    EikoInt,
    EikoResource,
    EikoStr,
)
from .definitions.context import CompilerContext, StorableTypes
from .definitions.function import (
    FunctionArg,
    FunctionDefinition,
    PluginDefinition,
)
from .definitions.resource import ResourceDefinition, ResourceProperty
from .errors import (
    EikoCompilationError,
    EikoInternalError,
    EikoParserError,
    EikoSyntaxError,
)
from .importlib import import_python_code, resolve_from_import, resolve_import
from .lexer import Lexer
from .ops import BINOP_MATRIX, BinOP
from .token import Token, TokenType


@dataclass
class ExprAST:
    """Base ExprAST. Purely Virtual."""

    token: Token

    def compile(self, _: CompilerContext) -> Optional[StorableTypes]:
        raise NotImplementedError


@dataclass
class EOFExprAST(ExprAST):
    """This ExprAST marks end of parsing."""

    def compile(self, _: CompilerContext) -> None:
        raise NotImplementedError


@dataclass
class IntExprAST(ExprAST):
    """AST representing an integer in the source"""

    def __post_init__(self) -> None:
        self.value = int(self.token.content)

    def compile(self, _: CompilerContext) -> EikoInt:
        return EikoInt(self.value)


@dataclass
class FloatExprAST(ExprAST):
    """AST representing a float in the source."""

    def __post_init__(self) -> None:
        self.value = float(self.token.content)

    def compile(self, _: CompilerContext) -> EikoFloat:
        return EikoFloat(self.value)


@dataclass
class BoolExprAST(ExprAST):
    """AST representing a bool in the source."""

    def __post_init__(self) -> None:
        if self.token.type == TokenType.FALSE:
            self.value = False
        elif self.token.type == TokenType.TRUE:
            self.value = True
        else:
            raise EikoInternalError(
                "Error occured trying to compile BoolExprAST. "
                "This is deffinetly a bug, please report it on github."
            )

    def compile(self, _: CompilerContext) -> EikoBool:
        return EikoBool(self.value)


@dataclass
class StringExprAST(ExprAST):
    """AST representing a string in the source."""

    def __post_init__(self) -> None:
        self.value = self.token.content

    def compile(self, _: CompilerContext) -> EikoStr:
        return EikoStr(self.value)


@dataclass
class UnaryNotExprAST(ExprAST):
    """AST representing a unary not operation."""

    rhs: ExprAST

    def compile(self, _: CompilerContext) -> EikoBaseType:
        raise NotImplementedError


@dataclass
class UnaryNegExprAST(ExprAST):
    """AST representing a unary negative operation."""

    rhs: ExprAST

    def compile(self, context: CompilerContext) -> Union[EikoInt, EikoFloat]:
        rhs = self.rhs.compile(context)
        if isinstance(rhs, EikoInt):
            return EikoInt(-rhs.value)

        if isinstance(rhs, EikoFloat):
            return EikoFloat(-rhs.value)

        if rhs is None:
            raise EikoCompilationError(
                "Unary negative expected value to the right hand side, "
                "but expression didn't return a usable value.",
                token=self.token,
            )

        raise EikoCompilationError(
            f"Unable to perform unary negative on object of type {rhs.type}",
            token=self.token,
        )


@dataclass
class BinOpExprAST(ExprAST):
    """A binary operation taking a left and right hand side."""

    lhs: ExprAST
    rhs: ExprAST

    def __post_init__(self) -> None:
        self.bin_op = BinOP.from_str(self.token.content)

    def compile(self, context: CompilerContext) -> EikoBaseType:
        lhs = self.lhs.compile(context)
        if lhs is None:
            raise EikoCompilationError(
                "Binary operation expected value on left hand side, "
                "but expression didn't return a usable value.",
                token=self.token,
            )

        rhs = self.rhs.compile(context)
        if rhs is None:
            raise EikoCompilationError(
                "Binary operation expected value on right hand side, "
                "but expression didn't return a usable value.",
                token=self.token,
            )

        arg_a_matrix = BINOP_MATRIX.get(lhs.type)
        if arg_a_matrix is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        arg_b_matrix = arg_a_matrix.get(rhs.type)
        if arg_b_matrix is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        op = arg_b_matrix.get(self.bin_op)
        if op is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        return op(lhs, rhs)  # type: ignore


@dataclass
class VariableAST(ExprAST):
    """An AST expressing a variable of some kind."""

    def __post_init__(self) -> None:
        self.identifier = self.token.content

    def compile(self, context: Union[CompilerContext, EikoBaseType]) -> StorableTypes:
        value = context.get(self.identifier)
        if value is None:
            raise EikoCompilationError(
                f"Variable {self.identifier} was accessed before "
                "having been assigned a value.",
                token=self.token,
            )

        return value


@dataclass
class AssignmentAST(ExprAST):
    """An AST expressing an assignment of some kind."""

    lhs: ExprAST
    rhs: ExprAST

    def compile(self, context: CompilerContext) -> StorableTypes:
        assignment_val = self.rhs.compile(context)
        if assignment_val is None:
            raise EikoCompilationError(
                "Assignment operation expected value on right hand side, "
                "but expression didn't return a usable value.",
                token=self.rhs.token,
            )

        if isinstance(self.lhs, VariableAST):
            context.set(self.lhs.token.content, assignment_val, self.token)
            return assignment_val

        if isinstance(self.lhs, DotExprAST):
            return self.lhs.assign(assignment_val, context)

        raise EikoCompilationError(
            "Assignment operation expected assignable variable on left hand side",
            token=self.token,
        )


@dataclass
class DotExprAST(ExprAST):
    """
    An AST expressing a dot expression. eg: 'thing.property'
    """

    lhs: Union["DotExprAST", VariableAST]
    rhs: ExprAST

    def compile(
        self, context: Union[CompilerContext, EikoBaseType, ResourceDefinition]
    ) -> Optional[StorableTypes]:
        lhs = self.lhs.compile(context)
        if isinstance(self.rhs, (VariableAST, CallExprAst, DotExprAST)) and isinstance(
            lhs, (EikoBaseType, ResourceDefinition, CompilerContext)
        ):
            return self.rhs.compile(lhs)

        raise EikoCompilationError(
            "Unable to perform dot expression on given token.",
            token=self.lhs.token,
        )

    def assign(self, value: StorableTypes, context: CompilerContext) -> StorableTypes:
        """Assign this dot expression a value of some kind."""
        lhs = self.lhs.compile(context)
        if isinstance(lhs, EikoResource):
            if isinstance(self.rhs, VariableAST):
                lhs.set(self.rhs.identifier, value, self.rhs.token)
                return value

            raise EikoCompilationError(
                f"Tried to assign value to {self.lhs.token.content}."
                f"{self.rhs.token.content}, but this is not a valid expression.",
                token=self.rhs.token,
            )
        raise EikoCompilationError(
            f"Tried to assign value to {self.lhs.token.content}."
            f"{self.rhs.token.content}, but this is not a valid expression.",
            token=self.lhs.token,
        )

    def to_import_traversable_list(self, import_list: List[str]) -> None:
        """
        Returns this dot expression as a list that can be used by the import system.
        """
        if isinstance(self.lhs, VariableAST):
            import_list.append(self.lhs.identifier)
        else:
            raise EikoCompilationError(
                "Unexpected token in import statement.",
                token=self.lhs.token,
            )

        if isinstance(self.rhs, VariableAST):
            import_list.append(self.rhs.identifier)
        elif isinstance(self.rhs, DotExprAST):
            self.rhs.to_import_traversable_list(import_list)
        else:
            raise EikoCompilationError(
                "Unexpected token in import statement.",
                token=self.rhs.token,
            )


@dataclass
class CallExprAst(ExprAST):
    """An AST expressing a resource-constructor or plugin."""

    def __post_init__(self) -> None:
        self.identifier = self.token.content
        self.args: List[ExprAST] = []

    def add_arg(self, expr: ExprAST) -> None:
        self.args.append(expr)

    def compile(
        self, context: Union[CompilerContext, EikoBaseType, ResourceDefinition]
    ) -> Optional[EikoBaseType]:
        eiko_callable: Optional[StorableTypes] = None
        if isinstance(context, CompilerContext):
            _obj = context.get(self.identifier)
            if isinstance(_obj, ResourceDefinition):
                eiko_callable = _obj.get(self.identifier)
            elif isinstance(_obj, PluginDefinition):
                eiko_callable = _obj
        else:
            eiko_callable = context.get(self.identifier)
        if isinstance(context, EikoBaseType):
            raise EikoInternalError(
                "Something went wrong, an EikoBaseType was passed to "
                "CallExprAST.compile instead of a CompilerContext. "
                "Please report this on github."
            )

        if isinstance(eiko_callable, FunctionDefinition):
            func_context = CompilerContext(f"func-{self.identifier}", context)
            self_arg = eiko_callable.args[0]
            resource = EikoResource(self_arg.type)
            func_context.set(self_arg.name, resource)
            for passed_arg, arg_definition in zip(self.args, eiko_callable.args[1:]):
                value = passed_arg.compile(func_context)
                if value is None:
                    raise EikoInternalError(
                        "Encountered bad value during compilation. "
                        "This is most likely a bug.\n"
                        "Please report this. (Value of parameter was Python None).\n"
                        f"Related token: {passed_arg.token}."
                    )
                if value.type != arg_definition.type:
                    raise EikoCompilationError(
                        f"Bad value was passed. Expected {arg_definition.type}, but got {value.type}.",
                        token=passed_arg.token,
                    )
                func_context.set(arg_definition.name, value)
            eiko_callable.execute(func_context)
            return resource

        if isinstance(eiko_callable, PluginDefinition):
            dummy_context = CompilerContext(f"{self.identifier}-plugin-call-context")
            return eiko_callable.execute(self.args, dummy_context)

        if eiko_callable is None:
            raise EikoCompilationError(
                f"No callable {self.identifier}.",
                token=self.token,
            )

        raise EikoCompilationError(
            f"{self.identifier} is not callable.",
            token=self.token,
        )


@dataclass
class ResourcePropertyAST:
    """An AST expressing a resource property."""

    token: Token
    type_expr: Union[VariableAST, DotExprAST]
    default_value: Optional[ExprAST] = None

    def __post_init__(self) -> None:
        self.name = self.token.content

    def compile(self, context: CompilerContext, resource_name: str) -> ResourceProperty:
        """Compile the ResourceProperty to something the ResourceDefinitionAST understands."""
        _type = self.type_expr.compile(context)
        if type(_type) in (EikoBaseType, CompilerContext) or _type is None:
            raise EikoCompilationError(
                f"{resource_name}.{self.name} was given an invalid type expression.",
                token=self.type_expr.token,
            )

        if self.default_value is not None:
            default_value = self.default_value.compile(context)
            if not isinstance(default_value, EikoBaseType) or default_value is None:
                raise EikoCompilationError(
                    f"{resource_name}.{self.name} was given an invalid default value.",
                    token=self.default_value.token,
                )

            if default_value.type != _type.type:
                raise EikoCompilationError(
                    f"Property {resource_name}.{self.name} has type {_type.type}, "
                    f"but default value is of type {default_value.type}",
                    token=self.default_value.token,
                )
        else:
            default_value = None

        return ResourceProperty(self.name, _type.name, default_value)


@dataclass
class ResourceDefinitionAST(ExprAST):
    """
    A resource definition represents the resources properties and constructors.
    """

    name: str

    def __post_init__(self) -> None:
        self.properties: Dict[str, ResourcePropertyAST] = {}

    def add_property(self, new_property: ResourcePropertyAST) -> None:
        self.properties[new_property.name] = new_property

    def compile(self, context: CompilerContext) -> ResourceDefinition:
        resource_definition = ResourceDefinition(self.name, self.token)

        default_constructor = FunctionDefinition()
        default_constructor.add_arg(FunctionArg("self", self.name))
        for property_ast in self.properties.values():
            prop = property_ast.compile(context, self.name)
            resource_definition.add_property(prop)
            default_constructor.add_arg(
                FunctionArg(prop.name, prop.type, prop.default_value)
            )
            token = property_ast.token
            if token is None:
                token = Token(TokenType.IDENTIFIER, prop.name, self.token.index)
            default_constructor.add_body_expr(
                AssignmentAST(
                    self.token,
                    DotExprAST(
                        Token(TokenType.DOT, ".", token.index),
                        VariableAST(Token(TokenType.IDENTIFIER, "self", token.index)),
                        VariableAST(token),
                    ),
                    VariableAST(token),
                ),
            )

        resource_definition.add_constructor(self.name, default_constructor)
        context.set(self.name, resource_definition, self.token)

        return resource_definition


@dataclass
class ImportExprAST(ExprAST):
    """
    Represents an import of eiko code.
    """

    rhs: Union[VariableAST, DotExprAST]

    def compile(self, context: CompilerContext) -> None:
        import_list: List[str] = []
        if isinstance(self.rhs, VariableAST):
            import_list.append(self.rhs.identifier)
        else:
            self.rhs.to_import_traversable_list(import_list)

        resolve_result = resolve_import(import_list, context)
        if resolve_result is None:
            raise EikoCompilationError(
                f"Failed to import module, module {'.'.join(import_list)} not found.",
                token=self.token,
            )

        import_path, import_context = resolve_result

        import_python_code(import_list, import_path, import_context)
        parser = Parser(import_path)
        for expr in parser.parse():
            expr.compile(import_context)


@dataclass
class FromImportExprAST(ExprAST):
    """
    Represents a from ... import ... construct.
    """

    lhs: Union["DotExprAST", VariableAST]
    rhs: VariableAST

    def compile(self, context: CompilerContext) -> None:
        import_list: List[str] = []
        from_import_list: List[str] = []
        if isinstance(self.lhs, VariableAST):
            import_list.append(self.lhs.identifier)
            from_import_list.append(self.lhs.identifier)
        else:
            self.lhs.to_import_traversable_list(import_list)
            self.lhs.to_import_traversable_list(from_import_list)

        import_list.append(self.rhs.identifier)

        import_module = import_list
        resolve_result = resolve_from_import(import_module)
        if resolve_result is None:
            import_module = import_list[:-1]
            resolve_result = resolve_from_import(import_module)

        if resolve_result is None:
            raise EikoCompilationError(
                f"Module '{'.'.join(from_import_list)}' not found.",
                token=self.token,
            )

        import_path, import_context = resolve_result

        import_python_code(import_module, import_path, import_context)
        parser = Parser(import_path)
        for expr in parser.parse():
            expr.compile(import_context)

        if self.rhs.identifier in import_module:
            context.set(self.rhs.identifier, import_context)
        else:
            imported_item = import_context.get(self.rhs.identifier)
            if isinstance(imported_item, (EikoBaseType, ResourceDefinition)):
                context.set(self.rhs.identifier, imported_item)
            elif imported_item is None:
                raise EikoCompilationError(
                    f"Failed to import name '{self.rhs.identifier}' from '{'.'.join(from_import_list)}'.",
                    token=self.rhs.token,
                )
            else:
                raise EikoInternalError(
                    "Something went horribly wrong during a from ... import. "
                    "Please submit a bug report on github."
                )


class Parser:
    """
    Parses tokens 1 by 1, and turns them in to Expressions.
    """

    def __init__(self, file: Path) -> None:
        self.lexer = Lexer(file)
        self._current = self.lexer.next_token()
        self._next = self.lexer.next_token()
        self._bin_op_precedence = {
            "=": 10,
            "or": 20,
            "and": 30,
            "==": 50,
            "!=": 50,
            "<": 50,
            ">": 50,
            "<=": 50,
            ">=": 50,
            "+": 60,
            "-": 60,
            "*": 70,
            "/": 70,
            "//": 70,
            "%": 70,
            "u-": 80,
            "unot": 40,
            "**": 90,
            ".": 100,
        }

    def parse(self) -> Iterator[ExprAST]:
        """Parses tokens and constructs the next set of ASTs."""
        expr = self._parse_top_level()
        while not isinstance(expr, EOFExprAST):
            yield expr
            expr = self._parse_top_level()

    def print_op_precedence(self) -> None:
        """outputs every level and ops associated with said level."""
        op_precedents: Dict[int, List[str]] = {}
        for key, value in self._bin_op_precedence.items():
            _list = op_precedents.get(value)
            if _list is None:
                _list = []
                op_precedents[value] = _list
            _list.append(key)

        for level, _list in sorted(op_precedents.items()):
            print(f"{level}: [", ", ".join(_list), "]")

    def _advance(self, skip_indentation: bool = False) -> None:
        self._current = self._next
        self._next = self.lexer.next_token()

        if skip_indentation and self._current.type == TokenType.INDENT:
            self._advance(skip_indentation)

        if (
            self._current.type == TokenType.STRING
            and self._next.type == TokenType.STRING
        ):
            self._next = Token(
                TokenType.STRING,
                self._current.content + self._next.content,
                self._current.index,
            )
            self._advance(skip_indentation)

        if (
            self._current.type == TokenType.INDENT
            and self._current.content == ""
            and self._next.type == TokenType.INDENT
        ):
            self._advance()

    def _parse_top_level(self) -> ExprAST:
        if not (
            self._current.type in [TokenType.INDENT, TokenType.EOF]
            or self._current.content == ""
        ):
            raise EikoParserError(
                f"Unexpected token: {self._current.content}.", token=self._current
            )

        self._advance()
        if self._current.type == TokenType.EOF:
            return EOFExprAST(self._current)

        if self._current.type == TokenType.RESOURCE:
            return self._parse_resource_definition()

        if self._current.type == TokenType.IMPORT:
            return self._parse_import()

        if self._current.type == TokenType.FROM:
            return self._parse_from_import()

        return self._parse_expression()

    def _parse_expression(self, precedence: int = 0) -> ExprAST:
        lhs = self._parse_primary()
        return self._parse_bin_op_rhs(precedence, lhs)

    def _parse_primary(self) -> ExprAST:
        if self._current.type == TokenType.INDENT:
            if self._current.content == "":
                self._advance()
                return self._parse_primary()

        if self._current.content in ["-", "not"]:
            return self._parse_unary_op()

        if self._current.type == TokenType.INTEGER:
            token = self._current
            self._advance()
            return IntExprAST(token)

        if self._current.type == TokenType.FLOAT:
            token = self._current
            self._advance()
            return FloatExprAST(token)

        if self._current.type == TokenType.STRING:
            token = self._current
            self._advance()
            return StringExprAST(token)

        if self._current.type == TokenType.LEFT_PAREN:
            return self._parse_parens()

        if self._current.type == TokenType.IDENTIFIER:
            return self._parse_identifier()

        raise EikoSyntaxError(
            f"Unexpected token {self._current.type.name}.", index=self._current.index
        )

    def _parse_unary_op(self) -> Union[UnaryNegExprAST, UnaryNotExprAST]:
        token = self._current
        self._advance()
        if token.content == "-":
            rhs = self._parse_expression(self._bin_op_precedence["u-"])
            return UnaryNegExprAST(token, rhs)

        rhs = self._parse_expression(self._bin_op_precedence["unot"])
        return UnaryNotExprAST(token, rhs)

    def _parse_parens(self) -> ExprAST:
        self._advance(skip_indentation=True)
        next_expr = self._parse_expression()
        if self._current.type == TokenType.INDENT:
            self._advance(skip_indentation=True)
        if self._current.type != TokenType.RIGHT_PAREN:
            raise EikoParserError("Unexpected token.", token=self._current)

        self._advance()
        return next_expr

    def _parse_bin_op_rhs(self, expr_precedence: int, lhs: ExprAST) -> ExprAST:
        while True:
            current_predecedence = self._bin_op_precedence.get(self._current.content, 0)
            if current_predecedence < expr_precedence:
                return lhs
            if self._current.type in [
                TokenType.INDENT,
                TokenType.RIGHT_PAREN,
                TokenType.COMMA,
                TokenType.IMPORT,
                TokenType.EOF,
            ]:
                return lhs

            bin_op_token = self._current
            self._advance()
            rhs = self._parse_primary()

            # if current op binds less tightly with rhs than the operator after rhs,
            # let the pending operator take rhs as it's lhs
            next_op_precedence = self._bin_op_precedence.get(self._current.content, 0)
            if expr_precedence < next_op_precedence:
                rhs = self._parse_bin_op_rhs(current_predecedence + 1, rhs)

            if bin_op_token.type == TokenType.ASSIGNMENT_OP:
                lhs = AssignmentAST(bin_op_token, lhs, rhs)
            elif bin_op_token.type == TokenType.DOT:
                if isinstance(lhs, (VariableAST, DotExprAST)):
                    lhs = DotExprAST(bin_op_token, lhs, rhs)
                else:
                    raise EikoParserError(
                        "Unexpected token. "
                        "Expected an identifier on the left side of the dot expression.",
                        token=lhs.token,
                    )
            else:
                lhs = BinOpExprAST(bin_op_token, lhs, rhs)

    def _parse_identifier(self) -> Union[VariableAST, CallExprAst]:
        token = self._current
        self._advance()
        if self._current.type == TokenType.LEFT_PAREN:
            self._advance()
            return self._parse_call_expr(token)

        return VariableAST(token)

    def _parse_call_expr(self, name_token: Token) -> CallExprAst:
        call_ast = CallExprAst(name_token)
        while True:
            expr = self._parse_expression()
            call_ast.add_arg(expr)
            if self._current.type == TokenType.RIGHT_PAREN:
                self._advance()
                break

            if self._current.type != TokenType.COMMA:
                raise EikoCompilationError(
                    "Unexpected token. Expected a comma or right parenthesis.",
                    token=self._current,
                )
            self._advance()
            if self._current.type == TokenType.RIGHT_PAREN:
                break

        return call_ast

    def _parse_resource_definition(self) -> ResourceDefinitionAST:
        if self._next.type != TokenType.IDENTIFIER:
            raise EikoCompilationError(
                f"Unexpected token {self._next.content}, "
                "expected resource identifier.",
                token=self._next,
            )

        rd_ast = ResourceDefinitionAST(self._current, self._next.content)

        self._advance()
        self._advance()

        if self._current.content != ":":
            raise EikoCompilationError(
                f"Unexpected token {self._current.content}.",
                token=self._current,
            )

        self._advance()
        if self._current.type != TokenType.INDENT:
            raise EikoCompilationError(
                f"Unexpected token {self._current.content}, "
                "expected indented code block.",
                token=self._current,
            )

        indent = self._current.content
        while self._current.type == TokenType.INDENT:
            if self._current.content == "":
                break
            if self._current.content != indent:
                raise EikoCompilationError(
                    "Unexpected indentation.",
                    token=self._current,
                )
            self._advance()
            prop = self._parse_resource_property()
            rd_ast.add_property(prop)

        return rd_ast

    def _parse_resource_property(self) -> ResourcePropertyAST:
        if self._current.type != TokenType.IDENTIFIER:
            raise EikoParserError(
                "Unexpected token. Expected a property identifier.",
                token=self._current,
            )

        token = self._current
        default_value = None

        self._advance()
        if self._current.content != ":":
            raise EikoParserError(
                "Unexpected token. "
                "Expected a colon seperating the identifier from it's type.",
                token=self._current,
            )

        self._advance()
        type_expr = self._parse_expression()
        if isinstance(type_expr, AssignmentAST):
            default_value = type_expr.rhs
            type_expr = type_expr.lhs

        if not isinstance(type_expr, (DotExprAST, VariableAST)):
            raise EikoCompilationError(
                "Invalid expression. Expected a type expression.",
                token=type_expr.token,
            )

        return ResourcePropertyAST(token, type_expr, default_value)

    def _parse_import(self) -> ImportExprAST:
        token = self._current
        self._advance()
        rhs = self._parse_expression()

        if isinstance(rhs, (VariableAST, DotExprAST)):
            return ImportExprAST(token, rhs)

        raise EikoCompilationError(
            "Unable to import given expression.",
            token=token,
        )

    def _parse_from_import(self) -> FromImportExprAST:
        import_token = self._current
        self._advance()
        lhs = self._parse_expression()
        if not isinstance(lhs, (DotExprAST, VariableAST)):
            raise EikoCompilationError(
                "Invalid expression in import statement.",
                token=lhs.token,
            )

        self._advance()
        rhs = self._parse_expression()
        if not isinstance(rhs, VariableAST):
            raise EikoCompilationError(
                "Invalid expression in import statement.",
                token=lhs.token,
            )

        return FromImportExprAST(import_token, lhs, rhs)
