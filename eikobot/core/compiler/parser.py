# pylint: disable=too-many-lines
"""
The parser is the single most important part of the Eikobot Compiler.
It takes tokens generated by the lexer and tries to make sense of them,
Returning them as ASTs.
These ASTs in turn can be compiled to Eikobot data.
"""
from copy import copy
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterator, List, Optional, Union

from eikobot.core.compiler.misc import Index

from .definitions.base_types import (
    EikoBaseType,
    EikoBool,
    EikoFloat,
    EikoInt,
    EikoResource,
    EikoStr,
)
from .definitions.context import CompilerContext, StorableTypes
from .definitions.function import (
    FunctionArg,
    FunctionDefinition,
    PluginDefinition,
)
from .definitions.resource import ResourceDefinition, ResourceProperty
from .errors import (
    EikoCompilationError,
    EikoInternalError,
    EikoParserError,
    EikoSyntaxError,
)
from .importlib import import_python_code, resolve_from_import, resolve_import
from .lexer import Lexer
from .ops import BINOP_MATRIX, BinOP, ComparisonOP, compare
from .token import Token, TokenType


@dataclass
class ExprAST:
    """Base ExprAST. Purely Virtual."""

    token: Token

    def compile(self, _: CompilerContext) -> Optional[StorableTypes]:
        raise NotImplementedError(self.token)


@dataclass
class EOFExprAST(ExprAST):
    """This ExprAST marks end of parsing."""

    def compile(self, _: CompilerContext) -> None:
        raise NotImplementedError


@dataclass
class IntExprAST(ExprAST):
    """AST representing an integer in the source"""

    def __post_init__(self) -> None:
        self.value = int(self.token.content)

    def compile(self, _: CompilerContext) -> EikoInt:
        return EikoInt(self.value)


@dataclass
class FloatExprAST(ExprAST):
    """AST representing a float in the source."""

    def __post_init__(self) -> None:
        self.value = float(self.token.content)

    def compile(self, _: CompilerContext) -> EikoFloat:
        return EikoFloat(self.value)


@dataclass
class BoolExprAST(ExprAST):
    """AST representing a bool in the source."""

    def __post_init__(self) -> None:
        if self.token.type == TokenType.FALSE:
            self.value = False
        elif self.token.type == TokenType.TRUE:
            self.value = True
        else:
            raise EikoInternalError(
                "Error occured trying to compile BoolExprAST. "
                "This is deffinetly a bug, please report it on github."
            )

    def compile(self, _: CompilerContext) -> EikoBool:
        return EikoBool(self.value)


@dataclass
class StringExprAST(ExprAST):
    """AST representing a string in the source."""

    def __post_init__(self) -> None:
        self.value = self.token.content

    def compile(self, _: CompilerContext) -> EikoStr:
        return EikoStr(self.value)


class FStringLexer(Lexer):
    """
    The FStringLexer replaces the normal lexer,
    when lexing f-strings.
    """

    # pylint: disable=super-init-not-called
    def __init__(self, token: Token) -> None:
        self._str_token = token
        self._content = token.content
        self._index = token.index
        self.file_path = token.index.file

        self._lexing_f_tokens = False
        self.expressions: List[str] = []

        self._char_index = 0
        self._line = 0
        self._col = 0
        self._current_line = 0
        self._current = ""

    def _record_expression(self) -> None:
        expression = self._current
        char_index = self._char_index - 1
        while True:
            char_index -= 1
            prev_char = self._content[char_index]
            expression = self._content[char_index] + expression
            if prev_char == "{":
                break

        self.expressions.append(expression)

    def next_token(self) -> Token:
        if self._current == "\\" and not self._lexing_f_tokens:
            self._next()
            if self._current == "{":
                self._next()

        if self._current == "{":
            self._next()
            self._lexing_f_tokens = True
            return Token(TokenType.INDENT, "", self._current_index())

        if self._lexing_f_tokens:
            if self._current == "}":
                self._record_expression()
                self._next()
                self._lexing_f_tokens = False
            else:
                if self._current == "EOF":
                    raise EikoParserError(
                        "Reached end of f-string while parsing expression.",
                        token=self._str_token,
                    )
                return super().next_token()

        if not self._lexing_f_tokens:
            if self._current == "EOF":
                return super().next_token()

            self._next()
            return self.next_token()

        self._str_token.index = self._current_index()
        raise EikoParserError(
            "Failed to parse f-string.",
            token=self._str_token,
        )


@dataclass
class FStringExprAST(ExprAST):
    """
    An f-string expression is a string that contains sub-expressions.
    These expressions are seperated out at parse time and
    filled in at compile time.
    """

    def __post_init__(self) -> None:
        self.string = self.token.content
        self.expressions: Dict[str, ExprAST] = {}

        # Find a way to not read the whole file again.
        parser = Parser(self.token.index.file)
        parser.lexer = FStringLexer(self.token)
        parser._current = parser.lexer.next_token()  # pylint: disable=protected-access
        parser._next = parser.lexer.next_token()  # pylint: disable=protected-access
        for index, expr in enumerate(parser.parse()):
            self.expressions[parser.lexer.expressions[index]] = expr

    def compile(self, context: CompilerContext) -> EikoStr:
        string = EikoStr(self.token.content)
        for raw_expr, expr in self.expressions.items():
            result = expr.compile(context)
            if result is None:
                raise EikoCompilationError(
                    "Tried to interpolate string, but expression did not result in a value",
                    token=self.token,
                )

            if not isinstance(result, (EikoBool, EikoFloat, EikoInt, EikoStr)):
                raise EikoCompilationError(
                    f"Unable to convert object of type {result.type} to a string "
                    "and interpolate it with an f-string. (Only bool, int, float and str are allowed.)",
                    token=self.token,
                )

            string.value = string.value.replace(raw_expr, str(result.value))

        return string


@dataclass
class UnaryNotExprAST(ExprAST):
    """AST representing a unary not operation."""

    rhs: ExprAST

    def compile(self, context: CompilerContext) -> EikoBaseType:
        rhs = self.rhs.compile(context)
        if isinstance(rhs, EikoBaseType):
            return EikoBool((not rhs.truthiness()))

        raise EikoCompilationError(
            "Bad value given to not operator.",
            token=self.rhs.token,
        )


@dataclass
class UnaryNegExprAST(ExprAST):
    """AST representing a unary negative operation."""

    rhs: ExprAST

    def compile(self, context: CompilerContext) -> Union[EikoInt, EikoFloat]:
        rhs = self.rhs.compile(context)
        if isinstance(rhs, EikoInt):
            return EikoInt(-rhs.value)

        if isinstance(rhs, EikoFloat):
            return EikoFloat(-rhs.value)

        raise EikoCompilationError(
            "Bad value given to unary negative exression.",
            token=self.rhs.token,
        )


@dataclass
class BinOpExprAST(ExprAST):
    """A binary operation taking a left and right hand side."""

    lhs: ExprAST
    rhs: ExprAST

    def __post_init__(self) -> None:
        self.bin_op = BinOP.from_str(self.token.content, self.token)

    def compile(self, context: CompilerContext) -> EikoBaseType:
        lhs = self.lhs.compile(context)
        rhs = self.rhs.compile(context)
        if lhs is None or rhs is None:
            raise EikoCompilationError(
                "Binary operation expected value but expression didn't return a value.",
                token=self.token,
            )

        arg_a_matrix = BINOP_MATRIX.get(lhs.type)
        if arg_a_matrix is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        arg_b_matrix = arg_a_matrix.get(rhs.type)
        if arg_b_matrix is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        op = arg_b_matrix.get(self.bin_op)
        if op is None:
            raise EikoCompilationError(
                f"No overload of operation {self.bin_op} for arguments"
                f"of types {lhs.type} and {rhs.type} available.",
                token=self.token,
            )

        # This needs to be cleaned up at some point, in some way,
        # but due to the way we retrieve 'op' from dictionaries,
        # mypy doesn't seem to know if this is valid.
        return op(lhs, rhs)  # type: ignore


@dataclass
class ComparisonExprAST(ExprAST):
    """An AST expressing a comparison."""

    lhs: ExprAST
    rhs: ExprAST

    def __post_init__(self) -> None:
        self.bin_op = ComparisonOP.from_str(self.token)

    def compile(self, context: CompilerContext) -> EikoBool:
        lhs = self.lhs.compile(context)
        rhs = self.rhs.compile(context)
        if lhs is None or rhs is None:
            raise EikoCompilationError(
                "Binary operation expected value but expression didn't return a value.",
                token=self.token,
            )

        if isinstance(lhs, (type, CompilerContext)):
            raise EikoInternalError(
                "Something went horribly wrong, please submit a bug report.",
                token=self.lhs.token,
            )

        if isinstance(rhs, (type, CompilerContext)):
            raise EikoInternalError(
                "Something went horribly wrong, please submit a bug report.",
                token=self.rhs.token,
            )

        return compare(lhs, rhs, self.bin_op, self.rhs.token)


@dataclass
class OrExprAST(ExprAST):
    """Expresses an OR operator."""

    lhs: ExprAST
    rhs: ExprAST

    def compile(self, context: CompilerContext) -> EikoBool:
        lhs = self.lhs.compile(context)

        if isinstance(lhs, EikoBaseType):
            rhs = self.rhs.compile(context)
            if isinstance(rhs, EikoBaseType):
                return EikoBool(lhs.truthiness() or rhs.truthiness())

            raise EikoCompilationError(
                "Expression did not result in a value usable by 'OR' operator",
                token=self.rhs.token,
            )

        raise EikoCompilationError(
            "Expression did not result in a value usable by 'OR' operator",
            token=self.lhs.token,
        )


@dataclass
class AndExprAST(ExprAST):
    """Expresses an AND operator."""

    lhs: ExprAST
    rhs: ExprAST

    def compile(self, context: CompilerContext) -> EikoBool:
        lhs = self.lhs.compile(context)

        if isinstance(lhs, EikoBaseType):
            rhs = self.rhs.compile(context)
            if isinstance(rhs, EikoBaseType):
                return EikoBool((lhs.truthiness() and rhs.truthiness()))

            raise EikoCompilationError(
                "Expression did not result in a value usable by 'AND' operator",
                token=self.rhs.token,
            )

        raise EikoCompilationError(
            "Expression did not result in a value usable by 'AND' operator",
            token=self.lhs.token,
        )


@dataclass
class VariableAST(ExprAST):
    """An AST expressing a variable of some kind."""

    def __post_init__(self) -> None:
        self.identifier = self.token.content

    def compile(self, context: Union[CompilerContext, EikoBaseType]) -> StorableTypes:
        value = context.get(self.identifier)
        if value is None:
            raise EikoCompilationError(
                f"Variable '{self.identifier}' was accessed before having been assigned a value.",
                token=self.token,
            )

        return value


@dataclass
class AssignmentAST(ExprAST):
    """An AST expressing an assignment of some kind."""

    lhs: ExprAST
    rhs: ExprAST

    def compile(self, context: CompilerContext) -> StorableTypes:
        assignment_val = self.rhs.compile(context)
        if assignment_val is None:
            raise EikoCompilationError(
                "Assignment operation expected value on right hand side, "
                "but expression didn't return a usable value.",
                token=self.rhs.token,
            )

        if isinstance(self.lhs, VariableAST):
            context.set(self.lhs.token.content, assignment_val, self.token)
            return assignment_val

        if isinstance(self.lhs, DotExprAST):
            return self.lhs.assign(assignment_val, context)

        raise EikoCompilationError(
            "Assignment operation expected assignable variable on left hand side",
            token=self.token,
        )


@dataclass
class DotExprAST(ExprAST):
    """
    An AST expressing a dot expression. eg: 'thing.property'
    """

    lhs: Union["DotExprAST", VariableAST]
    rhs: ExprAST

    def compile(
        self, context: Union[CompilerContext, EikoBaseType, ResourceDefinition]
    ) -> Optional[StorableTypes]:
        lhs = self.lhs.compile(context)
        if isinstance(self.rhs, (VariableAST, CallExprAst, DotExprAST)) and isinstance(
            lhs, (EikoBaseType, ResourceDefinition, CompilerContext)
        ):
            return self.rhs.compile(lhs)

        raise EikoCompilationError(
            "Unable to perform dot expression on given token.",
            token=self.lhs.token,
        )

    def assign(self, value: StorableTypes, context: CompilerContext) -> StorableTypes:
        """Assign this dot expression a value of some kind."""
        lhs = self.lhs.compile(context)
        if isinstance(lhs, EikoResource):
            if isinstance(self.rhs, VariableAST):
                lhs.set(self.rhs.identifier, value, self.rhs.token)
                return value

            raise EikoCompilationError(
                f"Tried to assign value to {self.lhs.token.content}."
                f"{self.rhs.token.content}, but this is not a valid expression.",
                token=self.rhs.token,
            )
        raise EikoCompilationError(
            f"Tried to assign value to {self.lhs.token.content}."
            f"{self.rhs.token.content}, but this is not a valid expression.",
            token=self.lhs.token,
        )

    def to_import_traversable_list(self, import_list: List[str]) -> None:
        """
        Returns this dot expression as a list that can be used by the import system.
        """
        if isinstance(self.lhs, VariableAST):
            import_list.append(self.lhs.identifier)
        else:
            raise EikoCompilationError(
                "Unexpected token in import statement.",
                token=self.lhs.token,
            )

        if isinstance(self.rhs, VariableAST):
            import_list.append(self.rhs.identifier)
        elif isinstance(self.rhs, DotExprAST):
            self.rhs.to_import_traversable_list(import_list)
        else:
            raise EikoCompilationError(
                "Unexpected token in import statement.",
                token=self.rhs.token,
            )


@dataclass
class CallExprAst(ExprAST):
    """An AST expressing a resource-constructor or plugin."""

    def __post_init__(self) -> None:
        self.identifier = self.token.content
        self.args: List[ExprAST] = []

    def add_arg(self, expr: ExprAST) -> None:
        self.args.append(expr)

    def compile(
        self, context: Union[CompilerContext, EikoBaseType, ResourceDefinition]
    ) -> Optional[EikoBaseType]:
        eiko_callable: Optional[StorableTypes] = None
        if isinstance(context, CompilerContext):
            _obj = context.get(self.identifier)
            if isinstance(_obj, ResourceDefinition):
                eiko_callable = _obj.get(self.identifier)
            elif isinstance(_obj, PluginDefinition):
                eiko_callable = _obj
        else:
            eiko_callable = context.get(self.identifier)
        if isinstance(context, EikoBaseType):
            raise EikoInternalError(
                "Something went wrong, an EikoBaseType was passed to "
                "CallExprAST.compile instead of a CompilerContext. "
                "Please report this on github."
            )

        if isinstance(eiko_callable, FunctionDefinition):
            func_context = CompilerContext(f"func-{self.identifier}", context)
            self_arg = eiko_callable.args[0]
            resource = EikoResource(self_arg.type)
            func_context.set(self_arg.name, resource)
            for passed_arg, arg_definition in zip(self.args, eiko_callable.args[1:]):
                value = passed_arg.compile(func_context)
                if value is None:
                    raise EikoInternalError(
                        "Encountered bad value during compilation. "
                        "This is most likely a bug.\n"
                        "Please report this. (Value of parameter was Python None).\n"
                        f"Related token: {passed_arg.token}."
                    )
                if value.type != arg_definition.type:
                    raise EikoCompilationError(
                        f"Bad value was passed. Expected {arg_definition.type}, but got {value.type}.",
                        token=passed_arg.token,
                    )
                func_context.set(arg_definition.name, value)
            eiko_callable.execute(func_context)
            return resource

        if isinstance(eiko_callable, PluginDefinition):
            dummy_context = CompilerContext(f"{self.identifier}-plugin-call-context")
            return eiko_callable.execute(self.args, dummy_context)

        if eiko_callable is None:
            raise EikoCompilationError(
                f"No callable {self.identifier}.",
                token=self.token,
            )

        raise EikoCompilationError(
            f"{self.identifier} is not callable.",
            token=self.token,
        )


@dataclass
class ResourcePropertyAST:
    """An AST expressing a resource property."""

    token: Token
    type_expr: Union[VariableAST, DotExprAST]
    default_value: Optional[ExprAST] = None

    def __post_init__(self) -> None:
        self.name = self.token.content

    def compile(self, context: CompilerContext, resource_name: str) -> ResourceProperty:
        """Compile the ResourceProperty to something the ResourceDefinitionAST understands."""
        _type = self.type_expr.compile(context)
        if type(_type) in (EikoBaseType, CompilerContext) or _type is None:
            raise EikoCompilationError(
                f"{resource_name}.{self.name} was given an invalid type expression.",
                token=self.type_expr.token,
            )

        if self.default_value is not None:
            default_value = self.default_value.compile(context)
            if not isinstance(default_value, EikoBaseType) or default_value is None:
                raise EikoCompilationError(
                    f"{resource_name}.{self.name} was given an invalid default value.",
                    token=self.default_value.token,
                )

            if default_value.type != _type.type:
                raise EikoCompilationError(
                    f"Property {resource_name}.{self.name} has type {_type.type}, "
                    f"but default value is of type {default_value.type}",
                    token=self.default_value.token,
                )
        else:
            default_value = None

        return ResourceProperty(self.name, _type.name, default_value)


@dataclass
class ResourceDefinitionAST(ExprAST):
    """
    A resource definition represents the resources properties and constructors.
    """

    name: str

    def __post_init__(self) -> None:
        self.properties: Dict[str, ResourcePropertyAST] = {}

    def add_property(self, new_property: ResourcePropertyAST) -> None:
        self.properties[new_property.name] = new_property

    def compile(self, context: CompilerContext) -> ResourceDefinition:
        resource_definition = ResourceDefinition(self.name, self.token)

        default_constructor = FunctionDefinition()
        default_constructor.add_arg(FunctionArg("self", self.name))
        for property_ast in self.properties.values():
            prop = property_ast.compile(context, self.name)
            resource_definition.add_property(prop)
            default_constructor.add_arg(
                FunctionArg(prop.name, prop.type, prop.default_value)
            )
            token = property_ast.token
            if token is None:
                token = Token(TokenType.IDENTIFIER, prop.name, self.token.index)
            default_constructor.add_body_expr(
                AssignmentAST(
                    self.token,
                    DotExprAST(
                        Token(TokenType.DOT, ".", token.index),
                        VariableAST(Token(TokenType.IDENTIFIER, "self", token.index)),
                        VariableAST(token),
                    ),
                    VariableAST(token),
                ),
            )

        resource_definition.add_constructor(self.name, default_constructor)
        context.set(self.name, resource_definition, self.token)

        return resource_definition


@dataclass
class ImportExprAST(ExprAST):
    """
    Represents an import of eiko code.
    """

    rhs: Union[VariableAST, DotExprAST]

    def compile(self, context: CompilerContext) -> None:
        import_list: List[str] = []
        if isinstance(self.rhs, VariableAST):
            import_list.append(self.rhs.identifier)
        else:
            self.rhs.to_import_traversable_list(import_list)

        resolve_result = resolve_import(import_list, context)
        if resolve_result is None:
            raise EikoCompilationError(
                f"Failed to import module, module {'.'.join(import_list)} not found.",
                token=self.token,
            )

        import_path, import_context = resolve_result

        import_python_code(import_list, import_path, import_context)
        parser = Parser(import_path)
        for expr in parser.parse():
            expr.compile(import_context)


@dataclass
class FromImportExprAST(ExprAST):
    """
    Represents a from ... import ... construct.
    """

    lhs: Union["DotExprAST", VariableAST]
    rhs: VariableAST

    def compile(self, context: CompilerContext) -> None:
        import_list: List[str] = []
        from_import_list: List[str] = []
        if isinstance(self.lhs, VariableAST):
            import_list.append(self.lhs.identifier)
            from_import_list.append(self.lhs.identifier)
        else:
            self.lhs.to_import_traversable_list(import_list)
            self.lhs.to_import_traversable_list(from_import_list)

        import_list.append(self.rhs.identifier)

        import_module = import_list
        resolve_result = resolve_from_import(import_module)
        if resolve_result is None:
            import_module = import_list[:-1]
            resolve_result = resolve_from_import(import_module)

        if resolve_result is None:
            raise EikoCompilationError(
                f"Module '{'.'.join(from_import_list)}' not found.",
                token=self.token,
            )

        import_path, import_context = resolve_result

        import_python_code(import_module, import_path, import_context)
        parser = Parser(import_path)
        for expr in parser.parse():
            expr.compile(import_context)

        if self.rhs.identifier in import_module:
            context.set(self.rhs.identifier, import_context)
        else:
            imported_item = import_context.get(self.rhs.identifier)
            if isinstance(imported_item, (EikoBaseType, ResourceDefinition)):
                context.set(self.rhs.identifier, imported_item)
            elif imported_item is None:
                raise EikoCompilationError(
                    f"Failed to import name '{self.rhs.identifier}' from '{'.'.join(from_import_list)}'.",
                    token=self.rhs.token,
                )
            else:
                raise EikoInternalError(
                    "Something went horribly wrong during a from ... import. "
                    "Please submit a bug report on github."
                )


@dataclass
class IfExprAST(ExprAST):
    """
    Represents an if ... else ... construct.
    """

    if_expr: ExprAST
    body: List[ExprAST]
    else_body: Optional[List[ExprAST]]

    def compile(self, context: CompilerContext) -> None:
        if_res = self.if_expr.compile(context)
        if isinstance(if_res, EikoBaseType):
            if if_res.truthiness():
                for expr in self.body:
                    expr.compile(context)

            else:
                if self.else_body is not None:
                    for expr in self.else_body:
                        expr.compile(context)

        else:
            raise EikoCompilationError(
                "Invalid expression for if statement.",
                token=self.if_expr.token,
            )


class Parser:
    """
    Parses tokens 1 by 1, and turns them in to Expressions.
    """

    def __init__(self, file: Path) -> None:
        self.lexer = Lexer(file)
        self._current = self.lexer.next_token()
        self._next = self.lexer.next_token()
        self._previous = self._current
        self._current_indent = ""
        self._bin_op_precedence = {
            "=": 10,
            "or": 20,
            "and": 30,
            "unot": 40,
            "==": 50,
            "!=": 50,
            "<": 50,
            ">": 50,
            "<=": 50,
            ">=": 50,
            "+": 60,
            "-": 60,
            "*": 70,
            "/": 70,
            "//": 70,
            "%": 70,
            "u-": 80,
            "**": 90,
            ".": 100,
        }

    def parse(self) -> Iterator[ExprAST]:
        """Parses tokens and constructs the next set of ASTs."""
        expr = self._parse_top_level()
        while not isinstance(expr, EOFExprAST):
            yield expr
            expr = self._parse_top_level()

    def print_op_precedence(self) -> None:
        """outputs every level and ops associated with said level."""
        op_precedents: Dict[int, List[str]] = {}
        for key, value in self._bin_op_precedence.items():
            _list = op_precedents.get(value)
            if _list is None:
                _list = []
                op_precedents[value] = _list
            _list.append(key)

        for level, _list in sorted(op_precedents.items()):
            print(f"{level}: [", ", ".join(_list), "]")

    def _advance(self, skip_indentation: bool = False) -> None:
        if self._current.type != TokenType.INDENT:
            self._previous = self._current
        self._current = self._next
        self._next = self.lexer.next_token()

        if skip_indentation and self._current.type == TokenType.INDENT:
            self._advance(skip_indentation)

        if (
            self._current.type == TokenType.STRING
            and self._next.type == TokenType.STRING
        ):
            self._next = Token(
                TokenType.STRING,
                self._current.content + self._next.content,
                self._current.index,
            )
            self._advance(skip_indentation)

        if (
            self._current.type == TokenType.INDENT
            and self._current.content == ""
            and self._next.type == TokenType.INDENT
        ):
            self._advance()

    def _parse_top_level(self) -> ExprAST:
        if not (
            self._current.type in [TokenType.INDENT, TokenType.EOF]
            or self._current.content == ""
        ):
            raise EikoParserError(
                f"Unexpected token: '{self._current.content}'.", token=self._current
            )

        self._advance(skip_indentation=True)
        if self._current.type == TokenType.EOF:
            return EOFExprAST(self._current)

        if self._current.type == TokenType.RESOURCE:
            return self._parse_resource_definition()

        if self._current.type == TokenType.IMPORT:
            return self._parse_import()

        if self._current.type == TokenType.FROM:
            return self._parse_from_import()

        return self._parse_expression()

    def _parse_expression(self, precedence: int = 0) -> ExprAST:
        lhs = self._parse_primary()
        return self._parse_bin_op_rhs(precedence, lhs)

    def _parse_primary(self) -> ExprAST:
        if self._current.type == TokenType.INDENT:
            if self._current.content == "":
                self._advance()
                return self._parse_primary()

        if self._current.content in ["-", "not"]:
            return self._parse_unary_op()

        if self._current.type in [TokenType.TRUE, TokenType.FALSE]:
            token = self._current
            self._advance()
            return BoolExprAST(token)

        if self._current.type == TokenType.INTEGER:
            token = self._current
            self._advance()
            return IntExprAST(token)

        if self._current.type == TokenType.FLOAT:
            token = self._current
            self._advance()
            return FloatExprAST(token)

        if self._current.type == TokenType.STRING:
            token = self._current
            self._advance()
            return StringExprAST(token)

        if self._current.type == TokenType.F_STRING:
            token = self._current
            self._advance()
            return FStringExprAST(token)

        if self._current.type == TokenType.LEFT_PAREN:
            return self._parse_parens()

        if self._current.type == TokenType.IDENTIFIER:
            return self._parse_identifier()

        if self._current.type == TokenType.IF:
            return self._parse_if()

        raise EikoSyntaxError(
            f"Unexpected token {self._current.type.name}.", index=self._current.index
        )

    def _parse_unary_op(self) -> Union[UnaryNegExprAST, UnaryNotExprAST]:
        token = self._current
        self._advance()
        if token.content == "-":
            rhs = self._parse_expression(self._bin_op_precedence["u-"])
            return UnaryNegExprAST(token, rhs)

        rhs = self._parse_expression(self._bin_op_precedence["unot"])
        return UnaryNotExprAST(token, rhs)

    def _parse_parens(self) -> ExprAST:
        self._advance(skip_indentation=True)
        next_expr = self._parse_expression()
        if self._current.type == TokenType.INDENT:
            self._advance(skip_indentation=True)
        if self._current.type != TokenType.RIGHT_PAREN:
            raise EikoParserError("Unexpected token.", token=self._current)

        self._advance()
        return next_expr

    def _parse_bin_op_rhs(self, expr_precedence: int, lhs: ExprAST) -> ExprAST:
        while True:
            current_predecedence = self._bin_op_precedence.get(self._current.content, 0)
            if current_predecedence < expr_precedence:
                return lhs
            if self._current.type in [
                TokenType.INDENT,
                TokenType.RIGHT_PAREN,
                TokenType.COMMA,
                TokenType.IMPORT,
                TokenType.COLON,
                TokenType.EOF,
            ]:
                return lhs

            bin_op_token = self._current
            self._advance()
            rhs = self._parse_primary()

            # if current op binds less tightly with rhs than the operator after rhs,
            # let the pending operator take rhs as it's lhs
            next_op_precedence = self._bin_op_precedence.get(self._current.content, 0)
            if expr_precedence < next_op_precedence:
                rhs = self._parse_bin_op_rhs(current_predecedence + 1, rhs)

            if bin_op_token.type == TokenType.ASSIGNMENT_OP:
                lhs = AssignmentAST(bin_op_token, lhs, rhs)
            elif bin_op_token.type == TokenType.DOT:
                if isinstance(lhs, (VariableAST, DotExprAST)):
                    lhs = DotExprAST(bin_op_token, lhs, rhs)
                else:
                    raise EikoParserError(
                        "Unexpected token. "
                        "Expected an identifier on the left side of the dot expression.",
                        token=lhs.token,
                    )
            elif bin_op_token.type == TokenType.COMPARISON_OP:
                lhs = ComparisonExprAST(bin_op_token, lhs, rhs)
            elif bin_op_token.type == TokenType.OR:
                lhs = OrExprAST(bin_op_token, lhs, rhs)
            elif bin_op_token.type == TokenType.AND:
                lhs = AndExprAST(bin_op_token, lhs, rhs)
            else:
                lhs = BinOpExprAST(bin_op_token, lhs, rhs)

    def _parse_identifier(self) -> Union[VariableAST, CallExprAst]:
        token = self._current
        self._advance()
        if self._current.type == TokenType.LEFT_PAREN:
            self._advance()
            return self._parse_call_expr(token)

        return VariableAST(token)

    def _parse_call_expr(self, name_token: Token) -> CallExprAst:
        call_ast = CallExprAst(name_token)
        while True:
            expr = self._parse_expression()
            call_ast.add_arg(expr)
            if self._current.type == TokenType.RIGHT_PAREN:
                self._advance()
                break

            if self._current.type != TokenType.COMMA:
                raise EikoParserError(
                    "Unexpected token. Expected a comma or right parenthesis.",
                    token=self._current,
                )
            self._advance()
            if self._current.type == TokenType.RIGHT_PAREN:
                break

        return call_ast

    def _parse_resource_definition(self) -> ResourceDefinitionAST:
        if self._next.type != TokenType.IDENTIFIER:
            raise EikoParserError(
                f"Unexpected token {self._next.content}, "
                "expected resource identifier.",
                token=self._next,
            )

        rd_ast = ResourceDefinitionAST(self._current, self._next.content)

        self._advance()
        self._advance()

        if self._current.content != ":":
            raise EikoParserError(
                f"Unexpected token {self._current.content}.",
                token=self._current,
            )

        self._advance()
        if self._current.type != TokenType.INDENT:
            raise EikoParserError(
                f"Unexpected token {self._current.content}, "
                "expected indented code block.",
                token=self._current,
            )

        indent = self._current.content
        while self._current.type == TokenType.INDENT:
            if self._current.content == "":
                break
            if self._current.content != indent:
                raise EikoParserError(
                    "Unexpected indentation.",
                    token=self._current,
                )
            self._advance()
            prop = self._parse_resource_property()
            rd_ast.add_property(prop)

        return rd_ast

    def _parse_resource_property(self) -> ResourcePropertyAST:
        if self._current.type != TokenType.IDENTIFIER:
            raise EikoParserError(
                "Unexpected token. Expected a property identifier.",
                token=self._current,
            )

        token = self._current
        default_value = None

        self._advance()
        if self._current.content != ":":
            prev = copy(self._previous)
            prev.index = Index(
                prev.index.line,
                prev.index.col + len(prev.content),
                prev.index.file,
            )
            raise EikoParserError(
                "Unexpected token. "
                "Expected a colon seperating the identifier from it's type.",
                token=prev,
            )

        self._advance()
        type_expr = self._parse_expression()
        if isinstance(type_expr, AssignmentAST):
            default_value = type_expr.rhs
            type_expr = type_expr.lhs

        if not isinstance(type_expr, (DotExprAST, VariableAST)):
            raise EikoParserError(
                "Invalid expression. Expected a type expression.",
                token=type_expr.token,
            )

        return ResourcePropertyAST(token, type_expr, default_value)

    def _parse_import(self) -> ImportExprAST:
        token = self._current
        self._advance()
        rhs = self._parse_expression()

        if isinstance(rhs, (VariableAST, DotExprAST)):
            return ImportExprAST(token, rhs)

        raise EikoParserError(
            "Unable to import given expression.",
            token=token,
        )

    def _parse_from_import(self) -> FromImportExprAST:
        import_token = self._current
        self._advance()
        lhs = self._parse_expression()
        if not isinstance(lhs, (DotExprAST, VariableAST)):
            raise EikoParserError(
                "Invalid expression in import statement.",
                token=lhs.token,
            )

        self._advance()
        rhs = self._parse_expression()
        if not isinstance(rhs, VariableAST):
            raise EikoParserError(
                "Invalid expression in import statement.",
                token=lhs.token,
            )

        return FromImportExprAST(import_token, lhs, rhs)

    def _parse_if(self) -> IfExprAST:
        if_token = self._current
        self._advance()

        if_expr = self._parse_expression()
        if not self._current.type == TokenType.COLON:
            raise EikoParserError(
                "Expected a ':' token to close IF expression.",
                token=Token(
                    TokenType.UNKNOWN,
                    "",
                    Index(
                        self._previous.index.line,
                        self._previous.index.col + len(self._previous.content),
                        self._previous.index.file,
                    ),
                ),
            )
        self._advance()

        if self._current.type == TokenType.INDENT:
            if_body = self._parse_body()
        else:
            if_body = [self._parse_expression()]
        else_body: Optional[List[ExprAST]] = None

        if (
            self._current.type == TokenType.INDENT
            and self._current.content == self._current_indent
        ):
            if self._next.type == TokenType.ELIF:
                self._advance()
                else_body = [self._parse_if()]

            elif self._next.type == TokenType.ELSE:
                self._advance()
                self._advance()
                if not self._current.type == TokenType.COLON:
                    raise EikoParserError(
                        "Expected a ':' after ELSE expression.",
                        token=Token(
                            TokenType.UNKNOWN,
                            "",
                            Index(
                                self._previous.index.line,
                                self._previous.index.col + len(self._previous.content),
                                self._previous.index.file,
                            ),
                        ),
                    )
                self._advance()
                if self._current.type == TokenType.INDENT:
                    else_body = self._parse_body()
                else:
                    else_body = [self._parse_expression()]

        return IfExprAST(if_token, if_expr, if_body, else_body)

    def _parse_body(self) -> List[ExprAST]:
        if (
            not self._current.type == TokenType.INDENT
            or self._current_indent >= self._current.content
        ):
            raise EikoParserError("Expected indented code block.", token=self._current)

        prev_indent = self._current_indent
        self._current_indent = self._current.content
        self._advance()

        body: List[ExprAST] = []
        while True:
            body.append(self._parse_expression())
            if self._current.type != TokenType.INDENT:
                raise EikoInternalError(
                    "Unexpected issue, please report this on github."
                )
            if self._current.content != self._current_indent:
                break
            self._advance()

        self._current_indent = prev_indent
        return body
